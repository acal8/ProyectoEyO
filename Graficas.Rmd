---
title: "Proyecto Estadística y Optimización"
subtitle: "Máster en Ciencia de Datos - UV"
author: "Adrián Carrasco Alcalá, Javier Herrero Pérez y Clara Montalvá Barcenilla"
date: "Curso 2025-2026"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```












# Organización del trabajo

El trabajo se ha dividido entre los miembros del grupo de la siguiente manera:

- Javier Herrero Pérez: Apartado 2 y 3.1

- Clara Montalvá Barcenilla: Apartado 3.2

- Adrián Carrasco Alcalá: Apartado 4



# Apartado 2

```{r pressure, echo=FALSE, message=FALSE, warning=FALSE, results='hide',fig.width=6, fig.height=3}
source("solucion_XXX.R", echo = F)
```

La optimización de la cartera en cada periodo $t$ requiere estimaciones del rendimiento esperado $\mu_t$ y de la matriz de covarianza $\Sigma_t$ para los $N=5$ activos. Para ello, se utilizó un enfoque de modelos de series temporales aplicando modelos autoregresivos ARIMA. Para cada uno de los cinco activos se ha adoptado un modelo ARIMA y se han ido estudiando los valores a partir del onestep. Los datos de los que disponemos están formados por 10 años (120 periodos), se ha decidido entrenar con 8 años y los otros 2 años como valores de test. La figura anterior permite evaluar la calidad del modelo de predicción ARIMA en el periodo de prueba. La gráfica muestra la comparación de los rendimientos reales frente a los rendimientos pronosticados para un solo acivo durante el periodo de prueba. Se observa que aunque la amplitud no sea perfecta, sí que es capaz de captar correctamente cuando sube y cuando baja.

El resultado del RMSE promedio es del 0.0175 ($1.75\%$) en el pronóstico de los 5 activos. Dado el comportamiento ruidoso de las series este resultado indica que el modelo ARIMA ha lorgrado capturar la componente predecible de la señal. La magnitud del error se debe principalmente a la componente impredecible. 

```{r, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}

library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)

gamma_values <- seq(from = 2, to = 20, length.out = 20) 

results_mv_sweep <- data.frame(
  Gamma = gamma_values,
  Retorno_MV = numeric(length(gamma_values)),
  Utilidad_MV = numeric(length(gamma_values))
)


for (i in seq_along(gamma_values)) {
  

  current_gammaMV <- gamma_values[i]
  

  alpha_hat <- getAlpha_ts(mu_hat, se_hat, current_gammaMV, getSigmaMV, getAlphaMV, Xtrain, Xtest)
  passChecks <- getChecks(alpha_hat, mode="sum1")
  ret <- getRet(alpha_hat, Xtest, passChecks)
  evals <- c(evals, retMV=ret)
  Umv_rel <- getUEval(alpha_hat, mu_hat, se_hat, Xtrain, Xtest, current_gammaMV, getSigmaMV, passChecks, Umv)
  evals <- c(evals,  Umv=Umv_rel)
  
  # d. Guardar los resultados
  results_mv_sweep$Retorno_MV[i] <- ret
  results_mv_sweep$Utilidad_MV[i] <- Umv_rel
}



gamma_values <- seq(from = 2, to = 20, length.out = 20) 

# 2. Inicializar un dataframe para guardar los resultados
results_mv_pos_sweep <- data.frame(
  Gamma = gamma_values,
  Retorno_MVPos = numeric(length(gamma_values)),
  Utilidad_MVPos = numeric(length(gamma_values))
)



for (i in seq_along(gamma_values)) {
  
  current_gammaMVPos <- gamma_values[i]
  

  alpha_hat <- getAlpha_ts(mu_hat, se_hat, current_gammaMVPos, getSigmaMVPos, getAlphaMVPos, Xtrain, Xtest)
  passChecks <- getChecks(alpha_hat, mode=c("sum1","pos"))
  ret <- getRet(alpha_hat, Xtest, passChecks)
  evals <- c(evals, retMVPos=ret)
  Umv_rel <- getUEval(alpha_hat, mu_hat, se_hat, Xtrain, Xtest, current_gammaMVPos, getSigmaMVPos, passChecks, Umv)
  evals <- c(evals,  UmvPos=Umv_rel)
  

  results_mv_pos_sweep$Retorno_MVPos[i] <- ret
  results_mv_pos_sweep$Utilidad_MVPos[i] <- Umv_rel
}


gamma_values <- seq(from = 2, to = 20, length.out = 20) 


results_log_sweep <- data.frame(
  Gamma = gamma_values,
  Retorno_Log = numeric(length(gamma_values)),
  Utilidad_Log = numeric(length(gamma_values)) # Este es el UmvPosInt
)



for (i in seq_along(gamma_values)) {
  
  current_gammaLog <- gamma_values[i]
  

  alpha_hat <- getAlpha_ts(mu_hat, se_hat, current_gammaLog, getSigmaLog, getAlphaLog, Xtrain, Xtest)
  passChecks <- getChecks(alpha_hat, mode=c("sum1"))
  ret <- getRet(alpha_hat, Xtest, passChecks)
  evals <- c(evals, retLog=ret)
  Umv_rel <- getUEval(alpha_hat, mu_hat, se_hat, Xtrain, Xtest, current_gammaLog, getSigmaLog, passChecks, Umv)
  
  results_log_sweep$Retorno_Log[i] <- ret
  results_log_sweep$Utilidad_Log[i] <- Umv_rel
}




df_mv <- results_mv_sweep %>% 
  select(Gamma, Retorno_MV, Utilidad_MV) %>% 
  rename(Retorno = Retorno_MV, Utilidad = Utilidad_MV) %>% 
  mutate(Modelo = "MV (Con Cortas)")


df_mv_pos <- results_mv_pos_sweep %>% 
  select(Gamma, Retorno_MVPos, Utilidad_MVPos) %>% 
  rename(Retorno = Retorno_MVPos, Utilidad = Utilidad_MVPos) %>% 
  mutate(Modelo = "MV (Sin Cortas)")

df_log <- results_log_sweep %>% 
  select(Gamma, Retorno_Log, Utilidad_Log) %>% 
  rename(Retorno = Retorno_Log, Utilidad = Utilidad_Log) %>% 
  mutate(Modelo = "Log-Utility")

```




# Apartado 3.1

La función de utilidad media-variana es
$U_{MV}(\alpha_t,\gamma;\mu_t,\Sigma_t)=\alpha_t^T \mu_t-\frac{\gamma}{2}\alpha_t^T \sum_t \alpha$.

Esta función se maximiza, esto equivale a minimizar $-U_{MV}$ sujeto a la restricción $\sum \alpha_t=1$. Se trata de un problema de programación cuadrática sin restricciones de desigualdad, entonces el problema a resolver es el siguiente:

$$Min\{ \frac{\gamma}{2} \alpha_t^T \sum_t \alpha_t - \alpha_t^T \mu_t\} \hspace{3mm} \text{s.a} \hspace{1mm} \sum \alpha_t=1$$

En este caso, donde se permiten las posiciones cortas, la solución óptima $\alpha^*$ se puede obtener de manera teórica mediante el uso de multiplicadores de Lagrange. Se define el Lagrangiano $L$ de la siguiente forma:

$$L=\frac{\gamma}{2} \alpha_t^T \sum_t \alpha_t - \alpha_t^T \mu_t + \lambda(\textbf{1}^T\cdot \alpha-1)$$
donde $\textbf{1}^T$ es un vector columna de 1 con N filas, donde N es el número de activos que en este problema es 5. Se resuelve el sistema:

$$\frac{\partial L}{\partial \alpha}=\gamma \Sigma \alpha^*-\mu+\lambda^* \textbf{1}=0$$
$$\frac{\partial L}{\partial \lambda}=\textbf{1}^T \alpha^*-1=0$$
donde $\alpha^*$, $\lambda^*$ las soluciones del sistema.

Sustituyendo se obtiene lo siguientes resultados:

$$\lambda^*=\frac{\textbf{1}^T\Sigma^{-1}\mu-\gamma}{\textbf{1}^T\Sigma^{-1}\textbf{1}}$$
$$\alpha^*=\frac{1}{\gamma}\Sigma^{-1}(\mu-\lambda^*\textbf{1})$$

Esta solución análisita se implementa directamente en la función **getAlphaMV**, lo que permite obtener el valor exacto de la asignación del portafolio $\alpha$. 

Para implementar la solución es necesario obtener la matriz de covarianza $\Sigma_t$ que se ha calculado previamente en **getSigmaMV**, este enfoque justifica el uso de los modelos ARIMA para la volatilidd (elementos diagonales de $\Sigma_t$) mientra que la dependencia entre los activos se saca de la historia de los datos.

```{r,fig.width=8, fig.height=3}

plot_retorno <- ggplot(df_mv, aes(x = Gamma, y = Retorno)) +
geom_line(size = 1.2) +
geom_point(size = 3) +
labs(
title = "Retorno Acumulado vs. Aversión al Riesgo",
x = expression(paste("Aversión al Riesgo (", gamma, ")")),
 y = "Retorno Acumulado"
) +
theme_minimal()+theme(plot.title = element_text(size = 12))

# 2. Gráfica de Utilidad Agregada
plot_utilidad <- ggplot(df_mv, aes(x = Gamma, y = Utilidad)) +
geom_line(size = 1.2) +
geom_point(size = 3) +
labs(
title = "Utilidad Agregada vs. Aversión al Riesgo",
 x = expression(paste("Aversión al Riesgo (", gamma, ")")),
y = "Utilidad Agregada"
) +
theme_minimal()+theme(plot.title = element_text(size = 12))

# Combinar las dos gráficas una al lado de la otra
plot_retorno | plot_utilidad

```

La gráfica muestra la relación entre el retorno acumulado y el parámetro de riesgo $\gamma$. El comportamiento genera que se observa es que el retorno cae drásticamente a medida que $\gamma$ aumenta hasta que se estabiliza. Tomar un valor pequeño de $\gamma$ conlleva tomar mucho riesgo, provocando un mayor retorno acumulado. 

- Riesgo mínimo: Elegir valores altos como $\gamma=20$ significa priorizar la minimización extrema del riesgo. Aunque esto resulta en cartera más segura, se observa que se penaliza excesivamente el rendimiento, logrando un retorno acumulado de $295\%$ y una utilidad promedio de $Y_{MV}=7.011$

- Balance óptimo: Si se busca un balance eficiente entre riesgo y retornoel valor de $\gamma=5$ es un punto destacable en la curva de la gráfica. Este valor impone un riesgo considerabley un retorno grande $9107\%$ lo que resulta en una utilidad agregada mucho mayor $U_{MV}=22.88$


Elegir valores $\gamma<5$ conllevarían un riesgo mucho mayor y a su vez un rendimiento elevado, si se busca un equilibrio entre rendimiento y seguridad el valor de $\gamma=5$ sería adecuado, pero si se busca maximizar el retorno el valor de $\gamma=1$ sería el adecuado.

Como Conclusión se elige $\gamma=5$ como el valor de riesgo ya que busca un rendimiento alto mientras que mantiene el riesgo bajo control según la curva mostrada.

# Resultados

```{r}
evals
```
