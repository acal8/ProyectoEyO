---
title: "Proyecto Estadística y Optimización"
subtitle: "Máster en Ciencia de Datos - UV"
author: "Adrián Carrasco Alcalá, Javier Herrero Pérez y Clara Montalvá Barcenilla"
date: "Curso 2025-2026"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(message = FALSE, warning = FALSE)
```












# Organización del trabajo

El trabajo se ha dividido entre los miembros del grupo de la siguiente manera:

- Javier Herrero Pérez: Apartado 2 y 3.1

- Clara Montalvá Barcenilla: Apartado 3.2

- Adrián Carrasco Alcalá: Apartado 4



# Apartado 2

```{r pressure, echo=FALSE, message=FALSE, warning=FALSE, results='hide', fig.width=6, fig.height=3}
source("solucion_XXX.R", echo = F)
```


La optimización de la cartera en cada periodo $t$ requiere estimaciones del rendimiento esperado $\mu_t$ y de la matriz de covarianza $\Sigma_t$ para los $N=5$ activos. Para ello, se utilizó un enfoque de modelos de series temporales aplicando modelos autoregresivos ARIMA. Para cada uno de los cinco activos se ha adoptado un modelo ARIMA y se han ido estudiando los valores a partir del onestep. Los datos de los que disponemos están formados por 10 años (120 periodos), se ha decidido entrenar con 8 años y los otros 2 años como valores de test. La figura anterior permite evaluar la calidad del modelo de predicción ARIMA en el periodo de prueba. La gráfica muestra la comparación de los rendimientos reales frente a los rendimientos pronosticados para un solo acivo durante el periodo de prueba. Se observa que aunque la amplitud no sea perfecta, sí que es capaz de captar correctamente cuando sube y cuando baja.

El resultado del RMSE promedio es del `r round(evals[1],4)` (`r round(evals[1],4)*100`$\%$) en el pronóstico de los 5 activos. Dado el comportamiento ruidoso de las series este resultado indica que el modelo ARIMA ha logrado capturar la componente predecible de la señal. La magnitud del error se debe principalmente a la componente impredecible.


```{r, echo=FALSE, message=FALSE, warning=FALSE, results='hide'}

library(dplyr)
library(tidyr)
library(ggplot2)
library(patchwork)

gamma_values <- seq(from = 2, to = 20, length.out = 20) 

results_mv_sweep <- data.frame(
  Gamma = gamma_values,
  Retorno_MV = numeric(length(gamma_values)),
  Utilidad_MV = numeric(length(gamma_values))
)


for (i in seq_along(gamma_values)) {
  

  current_gammaMV <- gamma_values[i]
  

  alpha_hat <- getAlpha_ts(mu_hat, se_hat, current_gammaMV, getSigmaMV, getAlphaMV, Xtrain, Xtest)
  passChecks <- getChecks(alpha_hat, mode="sum1")
  ret <- getRet(alpha_hat, Xtest, passChecks)
  evals <- c(evals, retMV=ret)
  Umv_rel <- getUEval(alpha_hat, mu_hat, se_hat, Xtrain, Xtest, current_gammaMV, getSigmaMV, passChecks, Umv)
  evals <- c(evals,  Umv=Umv_rel)
  
  # d. Guardar los resultados
  results_mv_sweep$Retorno_MV[i] <- ret
  results_mv_sweep$Utilidad_MV[i] <- Umv_rel
}



gamma_values <- seq(from = 2, to = 20, length.out = 20) 

# 2. Inicializar un dataframe para guardar los resultados
results_mv_pos_sweep <- data.frame(
  Gamma = gamma_values,
  Retorno_MVPos = numeric(length(gamma_values)),
  Utilidad_MVPos = numeric(length(gamma_values))
)



for (i in seq_along(gamma_values)) {
  
  current_gammaMVPos <- gamma_values[i]
  

  alpha_hat <- getAlpha_ts(mu_hat, se_hat, current_gammaMVPos, getSigmaMVPos, getAlphaMVPos, Xtrain, Xtest)
  passChecks <- getChecks(alpha_hat, mode=c("sum1","pos"))
  ret <- getRet(alpha_hat, Xtest, passChecks)
  evals <- c(evals, retMVPos=ret)
  Umv_rel <- getUEval(alpha_hat, mu_hat, se_hat, Xtrain, Xtest, current_gammaMVPos, getSigmaMVPos, passChecks, Umv)
  evals <- c(evals,  UmvPos=Umv_rel)
  

  results_mv_pos_sweep$Retorno_MVPos[i] <- ret
  results_mv_pos_sweep$Utilidad_MVPos[i] <- Umv_rel
}


gamma_values <- seq(from = 2, to = 20, length.out = 20) 


results_log_sweep <- data.frame(
  Gamma = gamma_values,
  Retorno_Log = numeric(length(gamma_values)),
  Utilidad_Log = numeric(length(gamma_values)) # Este es el UmvPosInt
)



for (i in seq_along(gamma_values)) {
  
  current_gammaLog <- gamma_values[i]
  

  alpha_hat <- getAlpha_ts(mu_hat, se_hat, current_gammaLog, getSigmaLog, getAlphaLog, Xtrain, Xtest)
  passChecks <- getChecks(alpha_hat, mode=c("sum1"))
  ret <- getRet(alpha_hat, Xtest, passChecks)
  evals <- c(evals, retLog=ret)
  Umv_rel <- getUEval(alpha_hat, mu_hat, se_hat, Xtrain, Xtest, current_gammaLog, getSigmaLog, passChecks, Umv)
  
  results_log_sweep$Retorno_Log[i] <- ret
  results_log_sweep$Utilidad_Log[i] <- Umv_rel
}




df_mv <- results_mv_sweep %>% 
  select(Gamma, Retorno_MV, Utilidad_MV) %>% 
  rename(Retorno = Retorno_MV, Utilidad = Utilidad_MV) %>% 
  mutate(Modelo = "MV (Con Cortas)")


df_mv_pos <- results_mv_pos_sweep %>% 
  select(Gamma, Retorno_MVPos, Utilidad_MVPos) %>% 
  rename(Retorno = Retorno_MVPos, Utilidad = Utilidad_MVPos) %>% 
  mutate(Modelo = "MV (Sin Cortas)")

df_log <- results_log_sweep %>% 
  select(Gamma, Retorno_Log, Utilidad_Log) %>% 
  rename(Retorno = Retorno_Log, Utilidad = Utilidad_Log) %>% 
  mutate(Modelo = "Log-Utility")

```




# Apartado 3.1

La función de utilidad media-varianza es
$U_{MV}(\alpha_t,\gamma;\mu_t,\Sigma_t)=\alpha_t^T \mu_t-\frac{\gamma}{2}\alpha_t^T \sum_t \alpha$.

Esta función se maximiza, esto equivale a minimizar $-U_{MV}$ sujeto a la restricción $\sum \alpha_t=1$. Se trata de un problema de programación cuadrática sin restricciones de desigualdad, entonces el problema a resolver es el siguiente:

$$Min\{ \frac{\gamma}{2} \alpha_t^T \sum_t \alpha_t - \alpha_t^T \mu_t\} \hspace{3mm} \text{s.a} \hspace{1mm} \sum \alpha_t=1$$

En este caso, donde se permiten las posiciones cortas, la solución óptima $\alpha^*$ se puede obtener de manera teórica mediante el uso de multiplicadores de Lagrange. Se define el Lagrangiano $L$ de la siguiente forma:

$$L=\frac{\gamma}{2} \alpha_t^T \sum_t \alpha_t - \alpha_t^T \mu_t + \lambda(\textbf{1}^T\cdot \alpha-1)$$
donde $\textbf{1}^T$ es un vector columna de 1 con N filas, donde N es el número de activos que en este problema es 5. Se resuelve el sistema:

$$\frac{\partial L}{\partial \alpha}=\gamma \Sigma \alpha^*-\mu+\lambda^* \textbf{1}=0$$
$$\frac{\partial L}{\partial \lambda}=\textbf{1}^T \alpha^*-1=0$$
donde $\alpha^*$, $\lambda^*$ las soluciones del sistema.

Sustituyendo se obtiene lo siguientes resultados:

$$\lambda^*=\frac{\textbf{1}^T\Sigma^{-1}\mu-\gamma}{\textbf{1}^T\Sigma^{-1}\textbf{1}}$$
$$\alpha^*=\frac{1}{\gamma}\Sigma^{-1}(\mu-\lambda^*\textbf{1})$$

Esta solución analítica se implementa directamente en la función **getAlphaMV**, lo que permite obtener el valor exacto de la asignación del portafolio $\alpha$. 

Para implementar la solución es necesario obtener la matriz de covarianza $\Sigma_t$ que se ha calculado previamente en **getSigmaMV**, este enfoque justifica el uso de los modelos ARIMA para la volatilidd (elementos diagonales de $\Sigma_t$) mientra que la dependencia entre los activos se saca de la historia de los datos.

```{r,fig.width=8, fig.height=3}

plot_retorno <- ggplot(df_mv, aes(x = Gamma, y = Retorno)) +
geom_line(size = 1.2) +
geom_point(size = 3) +
labs(
title = "Retorno Acumulado vs. Aversión al Riesgo",
x = expression(paste("Aversión al Riesgo (", gamma, ")")),
 y = "Retorno Acumulado"
) +
theme_minimal()+theme(plot.title = element_text(size = 12))

# 2. Gráfica de Utilidad Agregada
plot_utilidad <- ggplot(df_mv, aes(x = Gamma, y = Utilidad)) +
geom_line(size = 1.2) +
geom_point(size = 3) +
labs(
title = "Utilidad Agregada vs. Aversión al Riesgo",
 x = expression(paste("Aversión al Riesgo (", gamma, ")")),
y = "Utilidad Agregada"
) +
theme_minimal()+theme(plot.title = element_text(size = 12))

# Combinar las dos gráficas una al lado de la otra
plot_retorno | plot_utilidad

```

La gráfica muestra la relación entre el retorno acumulado y el parámetro de riesgo $\gamma$. El comportamiento genera que se observa es que el retorno cae drásticamente a medida que $\gamma$ aumenta hasta que se estabiliza. Tomar un valor pequeño de $\gamma$ conlleva tomar mucho riesgo, provocando un mayor retorno acumulado. 

- Riesgo mínimo: Elegir valores altos como $\gamma=20$ significa priorizar la minimización extrema del riesgo. Aunque esto resulta en cartera más segura, se observa que se penaliza excesivamente el rendimiento, logrando un retorno acumulado de $295\%$ y una utilidad promedio de $Y_{MV}=7.011$.

- Balance óptimo: Si se busca un balance eficiente entre riesgo y retorno el valor de $\gamma=5$ es un punto destacable en la curva de la gráfica. Este valor impone un riesgo considerable y un retorno grande $9107\%$ lo que resulta en una utilidad agregada mucho mayor $U_{MV}=22.88$.

Elegir valores $\gamma<5$ conllevaría un riesgo mucho mayor y a su vez un rendimiento elevado, si se busca un equilibrio entre rendimiento y seguridad el valor de $\gamma=5$ sería adecuado, pero si se busca maximizar el retorno el valor de $\gamma=1$ sería el adecuado.

Como conclusión se elige $\gamma=5$ como el valor de riesgo ya que busca un rendimiento alto mientras que mantiene el riesgo bajo control según la curva mostrada.

# Apartado 3.2

El objetivo sigue siendo maximizar la función de utilidad Media-Varianza, pero a diferencia del apartado 3.1, en este caso se prohíben las posiciones cortas, lo que introduce una restricción de desigualdad:

$$\alpha_{t,i} \ge 0 \quad \text{para todo } i=1,...,5$$

Al combinar esta restricción con la restricción de presupuesto (suma de ponderaciones igual a 1), el problema de optimización cuadrática a resolver es el siguiente:

$$\min_{\alpha} \left\{\frac{\gamma}{2}\alpha_{t}^{T}\Sigma_{t}\alpha_{t} - \alpha_{t}^{T}\mu_{t}\right\} \quad \text{s.a} \quad \sum_{i}\alpha_{t,i} = 1 \quad \text{y} \quad \alpha_{t,i} \ge 0$$

Debido a la presencia de la restricción de no-negatividad ($\alpha_i \ge 0$), la solución analítica con multiplicadores de Lagrange (Kuhn-Tucker) es más compleja y generalmente se aborda mediante métodos numéricos. Para resolver este problema de programación cuadrática de manera eficiente, se ha utilizado la función solve.QP de la librería de R quadprog. La función **getAlphaMVPos** implementa los siguientes componentes requeridos por quadprog:

- Matriz $D$ (Dmat_qp): matriz $D=\gamma\Sigma_t$, que define la parte cuadrática del problema.
- Vector $d$ (dvec_qp): vector $d=\mu_t$, que define la parte lineal.
- Matriz de Restricciones $A$ (Amat_qp): contiene las restricciones de igualdad y desigualdad.
1. Igualdad: $\sum_{i}\alpha_{t,i}=1$.
2. Desigualdad: $\alpha_{t,i} \ge 0$, representada por la matriz identidad $\mathbf{I}$ (A_ineq <- diag(n)).
- Vector $b$ (bvec_qp): contiene los valores de las restricciones (b_eq y b_ineq).

La solución obtenida proporciona la asignación óptima $\alpha^{*}$ para cada periodo $t$ sujeta a la prohibición de posiciones cortas.

La estimación de la matriz de covarianza $\Sigma_t$ para este apartado (**getSigmaMVPos**) se realiza con el mismo enfoque que en la Sección 3.1. La volatilidad individual (elementos diagonales $\sigma_{i,t}$) se obtiene de los modelos ARIMA del Apartado 2. La matriz de correlación ($R$) se estima a partir del historial de rendimientos y la matriz de covarianza se construye mediante la descomposición $\Sigma_t = DRD$.

```{r,fig.width=8, fig.height=3}
plot_retorno_pos <- ggplot(df_mv_pos, aes(x = Gamma, y = Retorno)) + 
  geom_line(size = 1.2) + 
  geom_point(size = 3) + 
  labs(
    title = "Retorno acumulado vs. Aversión al riesgo",
    x = expression(paste("Aversión al riesgo (", gamma, ")")),
    y = "Retorno acumulado"
  ) + 
  theme_minimal() + 
  theme(plot.title = element_text(size = 12))

# Gráfica 2: Utilidad Agregada vs. Aversión al Riesgo
plot_utilidad_pos <- ggplot(df_mv_pos, aes(x = Gamma, y = Utilidad)) + 
  geom_line(size = 1.2) + 
  geom_point(size = 3) + 
  labs(
    title = "Utilidad agregada vs. Aversión al riesgo",
    x = expression(paste("Aversión al riesgo (", gamma, ")")),
    y = "Utilidad agregada"
  ) + 
  theme_minimal() + 
  theme(plot.title = element_text(size = 12))

# Combinamos las dos gráficas
plot_retorno_pos | plot_utilidad_pos
```
Observando la gráfica, vemos que el retorno aumenta rápidamente hasta alcanzar su máximo alrededor de $\gamma=15$. A diferencia del caso sin restricciones, la utilidad muestra un mínimo cerca de $\gamma=6$ y luego aumenta progresivamente hasta $\gamma=20$. 
Este comportamiento se debe a la interacción entre la restricción de no posiciones cortas y el término de penalización por riesgo. Al aumentar $\gamma$, la cartera se vuelve menos volátil y se diversifica entre todos los actuvos, lo que puede aumentar el retorno ajustado por riesgo (utilidad). 

Este valor se justifica porque:
1. Maximiza el retorno acumulado (alcanzando el punto más alto de la curva).
2. Maximiza la utilidad agregada en el rango analizado.
3. Prioriza la diversificación, evitando la concentración extrema en un solo activo que ocurre con valores de $\gamma$ más pequeños (cercanos a 6), donde la utilidad es mínima.

# Resultados

```{r}
evals
```
